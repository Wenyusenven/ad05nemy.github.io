<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shellcode笔记(4)]]></title>
    <url>%2F2019%2F04%2F12%2Fshellcode-4%2F</url>
    <content type="text"><![CDATA[开始编写shellcode新建一个C语言控制台项目，首先把GS选项关闭写一段简单的代码12345678#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int entrymain()&#123; MessageBoxA(NULL,&quot;hello&quot;,&quot;tips&quot;,MB_OK); return 0;&#125; 代码只是弹出了一个消息框，并没有什么作用，现在用shellcode的写法改编首先要杜绝字符串的直接引用123456789#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int entrymain()&#123; char he[] = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,0&#125;; char tip[] = &#123;&apos;t&apos;,&apos;i&apos;,&apos;p&apos;,&apos;s&apos;,0&#125;; MessageBoxA(NULL,he,tip,MB_OK); return 0;&#125; 然后是函数的动态调用首先需要重新定义该函数，右键转到定义,复制函数原型用typedef定义一个指针12345typedef int(WINAPI *FN_MessageBoxA)( __in_opt HWND hWnd, __in_opt LPCSTR lpText, __in_opt LPCSTR lpCaption, __in UINT uType); 然后用LoadLibraryA函数获取user32.dll的地址,再用GetProcAddress函数获取MessageBoxA在user32.dll中的地址,再把函数地址赋值给指针同时，user32.dll和MessageBoxA字符串也需要做处理最终代码:1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int entrymain()&#123; char szuser32[] = &#123;&apos;u&apos;,&apos;s&apos;,&apos;e&apos;,&apos;r&apos;,&apos;3&apos;,&apos;2&apos;,&apos;.&apos;,&apos;d&apos;,&apos;l&apos;,&apos;l&apos;,0&#125;; char szmessage[] = &#123;&apos;M&apos;,&apos;e&apos;,&apos;s&apos;,&apos;s&apos;,&apos;a&apos;,&apos;g&apos;,&apos;e&apos;,&apos;B&apos;,&apos;o&apos;,&apos;x&apos;,&apos;A&apos;,0&#125;; typedef int(WINAPI *FN_MessageBoxA)( __in_opt HWND hWnd, __in_opt LPCSTR lpText, __in_opt LPCSTR lpCaption, __in UINT uType); FN_MessageBoxA fn_MessageBoxA = (FN_MessageBoxA)GetProcAddress(LoadLibraryA(szuser32),szmessage); char he[] = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,0&#125;; char tip[] = &#123;&apos;t&apos;,&apos;i&apos;,&apos;p&apos;,&apos;s&apos;,0&#125;; fn_MessageBoxA(NULL,he,tip,MB_OK); return 0;&#125; 编译运行一下运行成功]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode笔记(3)]]></title>
    <url>%2F2019%2F04%2F12%2Fshellcode-3%2F</url>
    <content type="text"><![CDATA[shellcode的编写原则ShelCode编写原则(规则更贴切)因为字符串直接赋值在内存中是一个绝对地址，存在于其它内存空间，shllcode在内存中运行时调用别的内存空间的地址可能会引起崩溃 杜绝双引号字符串的直接引用如:char buffer[] = “123456”;可用:char buffer[] = {‘1’,’2’,’3’,’4’,’5’,’6’,0};或者:12345678910111213char *buffer;_asm &#123; call _buffer _EMIT &apos;1&apos; :表占位，写入 _EMIT &apos;2&apos; _EMIT &apos;3&apos; _EMIT &apos;4&apos; _EMIT &apos;5&apos; _EMIT &apos;6&apos; _EMIT 0 :结束标志 _buffer: pop buffer &#125; 避免函数直接调用 因为不同的操作系统函数的地址也不一样，在编写shellcode时所调用的函数都是基于当前的操作系统和编译器所直接调用的函数，在其它操作系统平台上地址就会变化，所以需要动态调用函数 避免全局变量,避免使用static关键字 原因同1 所使用的每个函数都需先加载动态链接库 函数都存在于DLL(动态链接库)当中，在动态调用函数时都需要在内存中先加载动态链接库才能调用函数,如MessageBox函数存在于user32.dll中]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode笔记(2)]]></title>
    <url>%2F2019%2F04%2F11%2Fshellcode-2%2F</url>
    <content type="text"><![CDATA[实际编写一个例子:123456789#include &quot;stdio.h&quot;#include &quot;string.h&quot;int main()&#123; char buffer[8]; gets(buffer); printf(&quot;%s&quot;,buffer); return 0;&#125; 可以看到我在程序中定义了一个缓冲区长度为8的buffer,把输入的数据放在buffer里面，然后打印出来,用OD附加看看输入16个a，长度远远大于我定义的8个字节看看会发生什么字符a的ascii码即是61,可以看到，程序暂停了，并报出了访问违规再看看EIP寄存器变成了61616161EIP寄存器存放了下一跳指令的地址，61616161不是一个地址，也不是一个指令，导致了程序的异常终止再看堆栈窗口的数据四个地址全部61占满,我输入了16个a,刚好16个字节的地址大小，此处因为我输入了超出缓存区大小的数据，溢出覆盖了EIP寄存器，如果我输入的是构造好的shellcode,那么我就能执行任意代码，甚至获取一个系统shell]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode笔记(1)]]></title>
    <url>%2F2019%2F04%2F07%2Fshellcode-1%2F</url>
    <content type="text"><![CDATA[shellcode shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。来源：百度百科 缓冲区溢出 计算机程序一般都会使用到一些内存，这些内存或是程序内部使用，或是存放用户的输入数据，这样的内存一般称作缓冲区。溢出是指盛放的东西超出容器容量而溢出来了，在计算机程序中，就是数据使用到了被分配内存空间之外的内存空间。而缓冲区溢出，简单的说就是计算机对接收的输入数据没有进行有效的检测（理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符），向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。来源:百度百科 概述: 缓冲区溢出又叫堆栈溢出（还有许许多的称呼），这是计算机程序难以避免的漏洞，除非有新的设计方式将程序运行的堆栈设计取代。溢出的目的是重写程序的运行堆栈，使调用返回堆栈包含一个跳向预设好的程序的程序（代码），这个程序通常称为shellcode，通过这个shellcode就能获得如期的shell，更有可能获得root(权限)。 然后是windows内存结构，堆和栈 堆主要用来分配内存，栈用来存储函数之间的调用关系和顺序 PE文件 PE文件是windows下文件所遵循的一种数据格式常见的exe,dll都是PE文件,PE文件把文件分成几个数据节,不同的资源存放在不同的节中 .text节，由编译器产生,存放二进制的机器代码 .data节，初始化的数据块，存放全局变量，静态变量等 .idata节，可执行文件使用的动态链接库等外来函数的信息 .rsrc节,存放程序的资源，如图标，菜单. 然后是PE文件装载在栈内存的过程 ESP:栈顶指针寄存器(所有栈的栈顶)EBP:栈底指针寄存器(最上面一个栈的栈底)EIP:指向下一跳指令的寄存器 然后是函数调用的大概流程: 参数入栈：将参数从右到左压栈 返回地址入栈:将下一条指令的地址压栈 代码区跳转:从当前代码区跳转到被调用函数的入口处 栈帧调整 函数调用时的实现]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向笔记(2)]]></title>
    <url>%2F2019%2F04%2F04%2Freverse2%2F</url>
    <content type="text"><![CDATA[结合上篇继续jnz改成jz即可修改程序判断逻辑首先ZF是一个标志位，用来临时记录运算结果,若运算结果为真，则标志位ZF=1,否则ZF=0 JNZ：运算结果不为0则跳转(检查标志位ZF是否等于0,不为0则跳转)JZ：运算结果为0则跳转(检查标志位ZF是否等于1,不为1则跳转) 首先在jnz处下个断点，再运行程序可以看到此时Z标志位为0,把标志位修改为1,再运行程序再次提示login success!为什么改成jz照样能判断成功,因为正常运算为假，所以ZF=0，正常逻辑为jnz判断ZF此时=0，根据jnz不为1则跳转,所以跳转到password error提示语处,反之修改为jz为0则不跳转，顺序执行到login sucess!]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向笔记(1)]]></title>
    <url>%2F2019%2F04%2F01%2Freverse%2F</url>
    <content type="text"><![CDATA[用C语言粗略写了个验证字符串的代码如下:123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main()&#123;int shuz;scanf(&quot;please input password%d&quot;,&amp;shuz);if (shuz == 123)&#123; printf(&quot;login sucess!&quot;); system(&quot;pause&quot;);&#125;else&#123; printf(&quot;Password error!&quot;); system(&quot;pause&quot;);&#125;&#125; 可以看到程序判断输入是否为123如果是，则提示Login Success!不是则提示Password error!退出程序打开IDA加载程序 清楚的看到程序的逻辑流程jnz地址处则是判断逻辑的开始,空格跳转到汇编代码查看jnz的内存地址为 用OD附加进程看看,查找所有字符串 清楚的看到请输入密码的提示语，双击跳转到汇编语句所在的位置 看到提示成功和密码错误的提示语,结合在IDA找到的跳转指令内存地址 004A1019,加上OD内存位置的jnz可以得出00EA4019即是我们在IDA看到jnz跳转指令，为什么00401019变成了00EA1019,十进制01234换算十六进制分别是ABCDE，所以004A1019变成了00EA1019 把jnz改成jz重新运行程序 可以看到，随意输入的字符串也能判断成功!]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
</search>
